# 处理TCP字节流特性

## 需要考虑的情况
1. 如果发送数据无结构，如文件传输，这样发送方只管发送，接收方只管接收存储就 ok，不用考虑粘包；
2. 如果利用 TCP 短连接时，不会出现粘包问题；
3. 当发送数据存在一定结构，并且需要维护长连接时，则需要考虑粘包问题；

针对第三种情况有以下解决办法：
1. 在每条消息的头部加一个长度字段，*最常见的做法*；
2. 消息长度固定（亦即是提前确定包长度，适合定长消息包）；
3. 使用特殊的字符或字符串作为消息的边界，例如 HTTP 协议的 headers 以“\r\n”为字段的分隔符；
4. 利用消息本身的格式来分包，例如 XML 格式的消息中…的配对，或者json格式中的{…}的配对。解析这种消息格式通常会用到状态机

基于第一种做法：
其中头部字段是标记包体长度，服务号，版本号等等，包头长度需要固定
发送时转换为网络字节序或者直接定义为跨平台的类型，
包体是一个Json::Value格式的包体数据


-----

而server端一般都有一个应用层buffer
例如上述第三种会这样处理：
不断接收到的数据存放进buffer，直到匹配到一个消息边界,认为接收到一个完整的数据包,将其交给下一步处理(例如通过状态机),然后重置buffer,如果没有继续不断接受数据放进buffer

第一种情况亦同:
recv只管不断接受数据,然后存放进应用层buffer,我们根据队列头其中的包体长度来截取buffer中的一个个完整数据包交给下一步

